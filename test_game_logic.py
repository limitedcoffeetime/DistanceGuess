import unittest
import math
import random
from game_logic import Dot, generate_dot, generate_two_dots, calculate_euclidean_distance, is_guess_correct, COORDINATE_SYSTEM_MIN, COORDINATE_SYSTEM_MAX, CORRECT_ENOUGH_PERCENTAGE, Game, MAX_LIVES

class TestPhase1CoreGameLogic(unittest.TestCase):

    def test_1_coordinate_system(self):
        """
        Verification Checkpoint 1: Coordinate System Test
        - Verify that any generated point has x and y values between 0 and 1 inclusive
        - Check edge cases: can points be exactly at (0,0) or (1,1)?
        """
        for _ in range(1000):  # Generate a number of dots to test
            dot = generate_dot()
            self.assertTrue(COORDINATE_SYSTEM_MIN <= dot.x <= COORDINATE_SYSTEM_MAX, f"Dot x-coordinate {dot.x} out of bounds")
            self.assertTrue(COORDINATE_SYSTEM_MIN <= dot.y <= COORDINATE_SYSTEM_MAX, f"Dot y-coordinate {dot.y} out of bounds")

        # Test creation with edge case coordinates
        try:
            Dot(COORDINATE_SYSTEM_MIN, COORDINATE_SYSTEM_MIN)
            Dot(COORDINATE_SYSTEM_MAX, COORDINATE_SYSTEM_MAX)
            Dot(COORDINATE_SYSTEM_MIN, COORDINATE_SYSTEM_MAX)
            Dot(COORDINATE_SYSTEM_MAX, COORDINATE_SYSTEM_MIN)
        except ValueError:
            self.fail("Dot creation failed for edge case coordinates (0,0) or (1,1)")

        # Test creation outside bounds
        with self.assertRaises(ValueError, msg="Dot creation did not raise ValueError for x < MIN"):
            Dot(COORDINATE_SYSTEM_MIN - 0.1, COORDINATE_SYSTEM_MIN)
        with self.assertRaises(ValueError, msg="Dot creation did not raise ValueError for x > MAX"):
            Dot(COORDINATE_SYSTEM_MAX + 0.1, COORDINATE_SYSTEM_MIN)
        with self.assertRaises(ValueError, msg="Dot creation did not raise ValueError for y < MIN"):
            Dot(COORDINATE_SYSTEM_MIN, COORDINATE_SYSTEM_MIN - 0.1)
        with self.assertRaises(ValueError, msg="Dot creation did not raise ValueError for y > MAX"):
            Dot(COORDINATE_SYSTEM_MIN, COORDINATE_SYSTEM_MAX + 0.1)


    def test_2_dot_generation(self):
        """
        Verification Checkpoint 2: Dot Generation Distribution Test (Partial)
        - Generate 10,000 dots and verify their distribution is uniform across the plane (statistical check is complex, primarily checking bounds and difference)
        - Verify that successive calls produce different dot positions.
        """
        # Check bounds for a large number of dots (covered in test_1_coordinate_system as well)
        dots = [generate_dot() for _ in range(100)] # Reduced from 10000 for speed in unit test
        for dot in dots:
            self.assertTrue(COORDINATE_SYSTEM_MIN <= dot.x <= COORDINATE_SYSTEM_MAX)
            self.assertTrue(COORDINATE_SYSTEM_MIN <= dot.y <= COORDINATE_SYSTEM_MAX)

        # Verify that successive calls to generate_dot() are likely to produce different dots
        # This is probabilistic, but with enough samples, they should differ.
        dot_set = set()
        for _ in range(50): # Generate 50 dots
            dot = generate_dot()
            dot_set.add((dot.x, dot.y))
        self.assertTrue(len(dot_set) > 1, "generate_dot() produced identical dots over 50 calls or only one unique dot.")
        if len(dot_set) < 45 : # Arbitrary threshold, expecting high uniqueness
             print(f"Warning: Only {len(dot_set)} unique dots out of 50 generated by generate_dot(). Consider a larger sample if this is a concern.")


        # Verify that generate_two_dots() produces two different dots
        for _ in range(100):
            dot1, dot2 = generate_two_dots()
            self.assertNotEqual((dot1.x, dot1.y), (dot2.x, dot2.y), "generate_two_dots() produced identical dots")
            self.assertTrue(COORDINATE_SYSTEM_MIN <= dot1.x <= COORDINATE_SYSTEM_MAX)
            self.assertTrue(COORDINATE_SYSTEM_MIN <= dot1.y <= COORDINATE_SYSTEM_MAX)
            self.assertTrue(COORDINATE_SYSTEM_MIN <= dot2.x <= COORDINATE_SYSTEM_MAX)
            self.assertTrue(COORDINATE_SYSTEM_MIN <= dot2.y <= COORDINATE_SYSTEM_MAX)

    def test_3_distance_calculation(self):
        """
        Verification Checkpoint 3: Distance Calculation Test
        - Calculate distances between several predefined point pairs with known distances
        - Check edge cases: points at same location (distance = 0), diagonal corners (distance = âˆš2)
        - Verify precision of floating-point calculations
        """
        test_cases = [
            (Dot(0, 0), Dot(0, 0), 0),                                      # Same point
            (Dot(0, 0), Dot(1, 0), 1),                                      # Horizontal
            (Dot(0, 0), Dot(0, 1), 1),                                      # Vertical
            (Dot(0, 0), Dot(1, 1), math.sqrt(2)),                           # Diagonal (0,0) to (1,1)
            (Dot(COORDINATE_SYSTEM_MIN, COORDINATE_SYSTEM_MIN), Dot(COORDINATE_SYSTEM_MAX, COORDINATE_SYSTEM_MAX), math.sqrt( (COORDINATE_SYSTEM_MAX-COORDINATE_SYSTEM_MIN)**2 + (COORDINATE_SYSTEM_MAX-COORDINATE_SYSTEM_MIN)**2)), # Full diagonal
            (Dot(0.1, 0.1), Dot(0.4, 0.5), math.sqrt((0.4-0.1)**2 + (0.5-0.1)**2)), # (0.3, 0.4) -> 0.5
            (Dot(0.5, 0.5), Dot(0.5, 0.5), 0),
        ]

        for dot1, dot2, expected_distance in test_cases:
            calculated_distance = calculate_euclidean_distance(dot1, dot2)
            self.assertAlmostEqual(calculated_distance, expected_distance, places=7,
                                 msg=f"Distance calculation error for {dot1} and {dot2}. Expected {expected_distance}, got {calculated_distance}")

    def test_4_correct_range(self):
        """
        Verification Checkpoint 4: Correct Range Test
        - Verify that guesses within the defined "correct enough" range are properly identified
        - Test boundary conditions (exactly at acceptable error threshold)
        """
        actual_dist = 0.5
        # The 'tolerance' variable here will automatically use the imported CORRECT_ENOUGH_PERCENTAGE
        # which should be 0.15 after the change in game_logic.py
        tolerance = CORRECT_ENOUGH_PERCENTAGE

        # Test cases: (guessed_distance, expected_result)
        # With tolerance = 0.15 (15%):
        # Lower bound for 0.5 actual_dist: 0.5 * (1 - 0.15) = 0.5 * 0.85 = 0.425
        # Upper bound for 0.5 actual_dist: 0.5 * (1 + 0.15) = 0.5 * 1.15 = 0.575
        test_cases = [
            (actual_dist, True),                                      # Perfect guess (0.5)
            (actual_dist * (1 + tolerance / 2), True),                # Within tolerance (upper half, e.g., 0.5 * 1.075 = 0.5375)
            (actual_dist * (1 - tolerance / 2), True),                # Within tolerance (lower half, e.g., 0.5 * 0.925 = 0.4625)
            (actual_dist * (1 + tolerance), True),                    # Exactly at upper boundary (0.575)
            (actual_dist * (1 - tolerance), True),                    # Exactly at lower boundary (0.425)
            (actual_dist * (1 + tolerance * 1.00001), False),         # Just outside upper boundary (e.g., 0.575002625)
            (actual_dist * (1 - tolerance * 1.00001), False),         # Just outside lower boundary (e.g., 0.424997375)

            # New specific boundary checks for 15%
            (0.425, True),                                            # Exactly at lower 15% bound
            (0.575, True),                                            # Exactly at upper 15% bound
            (0.4249, False),                                          # Just below lower 15% bound
            (0.5751, False),                                          # Just above upper 15% bound

            (0.0, False if actual_dist > 0 else True),                # Guessing 0

            # Clearly outside cases (these should still be False)
            (actual_dist * 0.8, False),                               # 20% off (0.4) -> too low
            (actual_dist * 1.2, False),                               # 20% off (0.6) -> too high
            (0.3, False), # actual_dist = 0.5, 0.3 is 40% off
            (0.7, False)  # actual_dist = 0.5, 0.7 is 40% off
        ]

        for guessed_dist, expected_correctness in test_cases:
            # Ensure guessed_dist is not negative for these tests, unless actual_dist is also negative (which is not the case here)
            if guessed_dist < 0:
                 with self.assertRaises(ValueError): #is_guess_correct should raise ValueError for negative guess if actual is not
                     is_guess_correct(actual_dist, guessed_dist)
                 continue


            result = is_guess_correct(actual_dist, guessed_dist, tolerance)
            self.assertEqual(result, expected_correctness,
                             msg=f"Correct range test failed for actual={actual_dist}, guess={guessed_dist}, tolerance={tolerance*100}%. Expected {expected_correctness}, got {result}")

        # Test with actual_distance = 0
        self.assertTrue(is_guess_correct(0.0, 0.0, tolerance), "Guessing 0 for actual 0 should be correct")
        self.assertFalse(is_guess_correct(0.0, 0.00001, tolerance), "Guessing non-zero for actual 0 should be incorrect")

        # Test negative inputs (should raise ValueError)
        with self.assertRaises(ValueError):
            is_guess_correct(-0.1, 0.5)
        with self.assertRaises(ValueError):
            is_guess_correct(0.5, -0.1)
        with self.assertRaises(ValueError):
            is_guess_correct(-0.5, -0.1)


# Phase 5: Game Progression System Tests (New)
class TestGameProgression(unittest.TestCase):
    def setUp(self):
        """Set up a new Game instance for each test."""
        self.game = Game(initial_lives=3)
        # Ensure game starts with known dots for predictable tests, if necessary
        # For now, rely on the Game class's start_new_round during init

    def test_initial_lives(self):
        """1. Lives System Test: Verify player starts with 3 lives."""
        self.assertEqual(self.game.lives, 3, "Game should start with 3 lives.")
        self.assertEqual(self.game.max_lives, MAX_LIVES, f"Max lives should be {MAX_LIVES}")

    def test_lose_life_on_incorrect_guess(self):
        """1. Lives System Test: Check that incorrect guesses reduce lives by 1."""
        initial_lives = self.game.lives
        # Force an incorrect guess
        actual_dist = self.game.actual_distance
        bad_guess = actual_dist * (1 + CORRECT_ENOUGH_PERCENTAGE * 2) # Well outside tolerance
        self.game.submit_guess(bad_guess)
        self.assertEqual(self.game.lives, initial_lives - 1, "Incorrect guess should decrease lives by 1.")

    def test_gain_life_on_correct_guess(self):
        """1. Lives System Test: Verify correct guesses add 1 life (unless at maximum)."""
        self.game.lives = 1 # Start with 1 life to test gain
        initial_lives = self.game.lives
        actual_dist = self.game.actual_distance
        good_guess = actual_dist # Perfect guess
        self.game.submit_guess(good_guess)
        self.assertEqual(self.game.lives, initial_lives + 1, "Correct guess should increase lives by 1.")

    def test_max_lives_limit(self):
        """1. Lives System Test: Test maximum lives limit functionality."""
        self.game.lives = self.game.max_lives # Start at max lives
        actual_dist = self.game.actual_distance
        good_guess = actual_dist # Perfect guess
        self.game.submit_guess(good_guess)
        self.assertEqual(self.game.lives, self.game.max_lives, "Lives should not exceed max_lives.")

        # Test gaining a life when below max
        self.game.lives = self.game.max_lives -1
        self.game.submit_guess(good_guess)
        self.assertEqual(self.game.lives, self.game.max_lives, "Life should be gained up to max_lives.")


    def test_error_tracking_and_mean_error(self):
        """3. Error Tracking Test: Verify error scores and running mean error."""
        # Known dot positions for predictable distance
        self.game.current_dot1 = Dot(0.0, 0.0)
        self.game.current_dot2 = Dot(0.3, 0.4) # Distance = 0.5
        self.game.actual_distance = calculate_euclidean_distance(self.game.current_dot1, self.game.current_dot2)
        self.game.current_round_number = 1 # Reset round for this specific test setup
        self.game.error_scores = [] # Clear any previous scores
        self.assertEqual(self.game.actual_distance, 0.5)

        # Guess 1: 0.6 (Error: 0.1)
        self.game.submit_guess(0.6)
        self.assertAlmostEqual(self.game.error_scores[-1], 0.1)
        self.assertAlmostEqual(self.game.running_mean_error, 0.1)

        # Guess 2: 0.45 (Error: 0.05)
        self.game.submit_guess(0.45)
        self.assertAlmostEqual(self.game.error_scores[-1], 0.05)
        self.assertAlmostEqual(self.game.running_mean_error, (0.1 + 0.05) / 2)

        # Guess 3 (correct): 0.5 (Error: 0.0)
        self.game.submit_guess(0.5)
        self.assertAlmostEqual(self.game.error_scores[-1], 0.0)
        self.assertAlmostEqual(self.game.running_mean_error, (0.1 + 0.05 + 0.0) / 3)

    def test_next_round_generation(self):
        """6. Round Generation Test: Verify new dots are generated for each round."""
        initial_dot1 = self.game.current_dot1
        initial_dot2 = self.game.current_dot2
        initial_actual_distance = self.game.actual_distance
        initial_round_number = self.game.current_round_number

        self.game.next_round()

        self.assertNotEqual(self.game.current_dot1, initial_dot1, "Dot1 should change on next round.")
        self.assertNotEqual(self.game.current_dot2, initial_dot2, "Dot2 should change on next round.")
        # It's possible, though statistically very unlikely, that new dots result in the same distance.
        # A more robust test might check dot coordinates themselves if distances were equal.
        # self.assertNotEqual(self.game.actual_distance, initial_actual_distance, "Actual distance should typically change on next round.")
        self.assertTrue( (self.game.current_dot1.x != initial_dot1.x or self.game.current_dot1.y != initial_dot1.y) or \
                         (self.game.current_dot2.x != initial_dot2.x or self.game.current_dot2.y != initial_dot2.y), \
                         "At least one dot's coordinates should change on next round.")

        self.assertEqual(self.game.current_round_number, initial_round_number + 1, "Round number should increment.")

    def test_game_over_condition(self):
        """ Test that game.is_game_over() is true when lives are 0 or less """
        self.game.lives = 1
        actual_dist = self.game.actual_distance
        bad_guess = actual_dist * 2 # Incorrect guess
        self.game.submit_guess(bad_guess)
        self.assertTrue(self.game.is_game_over(), "Game should be over when lives reach 0.")
        self.assertEqual(self.game.lives, 0)

    def test_submit_guess_no_active_round(self):
        game = Game()
        game.actual_distance = None # Simulate no active round
        with self.assertRaises(ValueError):
            game.submit_guess(0.5)

    def test_submit_negative_guess(self):
        game = Game()
        with self.assertRaises(ValueError):
            game.submit_guess(-0.5)

# Phase 6: Game Completion Logic Tests
class TestPhase6GameCompletionLogic(unittest.TestCase):
    def setUp(self):
        self.initial_lives_setting = 3 # Consistent with default Game class
        self.game = Game(initial_lives=self.initial_lives_setting)

    def test_1_game_over_detection(self):
        """Phase 6: Verification 1: Game Over Detection Test
        - Verify game ends when lives reach zero.
        - Test that game state transitions correctly (verified by is_game_over()).
        - Ensure no further guesses can be made (implicitly, by UI state change or if submit_guess had checks).
        """
        self.game.lives = 1 # Set lives to 1 for a quick game over
        self.assertFalse(self.game.is_game_over(), "Game should not be over with 1 life.")

        # Force an incorrect guess
        actual_dist = self.game.actual_distance
        # Ensure actual_dist is not None (it should be set by start_new_round in __init__)
        self.assertIsNotNone(actual_dist, "Actual distance should be set in a new game.")
        bad_guess = actual_dist * (1 + CORRECT_ENOUGH_PERCENTAGE * 2) # Guaranteed incorrect

        self.game.submit_guess(bad_guess)
        self.assertEqual(self.game.lives, 0, "Lives should be 0 after depleting the last life.")
        self.assertTrue(self.game.is_game_over(), "is_game_over() should be true when lives are 0.")

        # Test that submitting another guess when game is over doesn't change lives or error count
        current_error_scores_count = len(self.game.error_scores)
        current_lives = self.game.lives # Should be 0

        # Try submitting again. With the fix, this should not raise an error or change state.
        self.game.submit_guess(bad_guess)

        self.assertEqual(self.game.lives, current_lives, "Lives should remain unchanged if guess submitted after game over.")
        self.assertEqual(self.game.lives, 0, "Lives should specifically be 0 after game over and another guess attempt.")
        self.assertEqual(len(self.game.error_scores), current_error_scores_count, "Error scores should not be added after game is over.")

    def test_2_game_over_screen_data(self):
        """Phase 6: Verification 2: Game Over Screen Test (Data verification)
        - Verify final statistics are displayed correctly (total rounds, mean error).
        Note: This tests the data provided by the Game class, not the UI rendering.
        """
        # Play a few rounds
        self.game.lives = 1 # Start with 1 life to make game over quick

        # Round 1 (from setUp)
        initial_round_number = self.game.current_round_number # Should be 1
        actual_dist_r1 = self.game.actual_distance
        self.assertIsNotNone(actual_dist_r1)
        guess_r1 = actual_dist_r1 * 0.5 # Incorrect, error = 0.5 * actual_dist_r1
        error_r1 = abs(actual_dist_r1 - guess_r1)
        self.game.submit_guess(guess_r1) # This guess makes lives = 0, game over

        self.assertTrue(self.game.is_game_over(), "Game should be over.")
        self.assertEqual(self.game.current_round_number, initial_round_number, "Round number should reflect rounds played up to game over.")
        self.assertAlmostEqual(self.game.running_mean_error, error_r1, msg="Mean error should be based on the single guess.")

        # Test with multiple rounds before game over
        game2 = Game(initial_lives=2)
        # Round 1 (auto by init)
        dist_g2_r1 = game2.actual_distance
        guess_g2_r1 = dist_g2_r1 * 0.5 # Incorrect, error1
        _, err1 = game2.submit_guess(guess_g2_r1) # Lives = 1
        self.assertEqual(game2.current_round_number, 1)

        # Round 2
        game2.next_round()
        dist_g2_r2 = game2.actual_distance
        guess_g2_r2 = dist_g2_r2 * 1.5 # Incorrect, error2
        _, err2 = game2.submit_guess(guess_g2_r2) # Lives = 0, game over
        self.assertEqual(game2.current_round_number, 2)

        self.assertTrue(game2.is_game_over(), "Game 2 should be over.")
        expected_mean_error_g2 = (err1 + err2) / 2.0
        self.assertAlmostEqual(game2.running_mean_error, expected_mean_error_g2, msg="Mean error for game2 is incorrect.")
        # Final statistics would be game2.current_round_number and game2.running_mean_error

    def test_3_restart_functionality_logic(self):
        """Phase 6: Verification 3: Restart Functionality Test (Logic)
        - Check that all game variables reset properly on restart (simulated by new Game instance).
        - Ensure the game returns to the initial state with new dots.
        """
        # Play the initial game for a bit
        self.game.submit_guess(self.game.actual_distance * 0.5) # Incorrect guess
        self.game.next_round()
        self.game.submit_guess(self.game.actual_distance * 0.2) # Another incorrect guess

        self.assertNotEqual(self.game.lives, self.initial_lives_setting, "Lives should have changed from initial.")
        self.assertTrue(len(self.game.error_scores) > 0, "Error scores should exist.")
        self.assertNotEqual(self.game.running_mean_error, 0.0, "Mean error should not be zero.")
        self.assertGreater(self.game.current_round_number, 1, "Round number should be greater than 1.")
        original_dot1 = self.game.current_dot1

        # Simulate restart by creating a new Game instance
        restarted_game = Game(initial_lives=self.initial_lives_setting)

        self.assertEqual(restarted_game.lives, self.initial_lives_setting, "Restarted game should have initial lives.")
        self.assertEqual(len(restarted_game.error_scores), 0, "Restarted game should have no error scores.")
        self.assertEqual(restarted_game.running_mean_error, 0.0, "Restarted game should have zero mean error.")
        self.assertEqual(restarted_game.current_round_number, 1, "Restarted game should be on round 1.") # Game init calls start_new_round, so round is 1
        self.assertIsNotNone(restarted_game.current_dot1, "Restarted game should have a new dot1.")
        self.assertIsNotNone(restarted_game.current_dot2, "Restarted game should have a new dot2.")
        # Check if dots are genuinely new (highly probable, but not strictly guaranteed if random repeats)
        # A simple check: ensure the new dot1 is not the same instance as the old game's last dot1
        # or that its coordinates are different (more robust for truly new dots)
        if restarted_game.current_dot1 is not None and original_dot1 is not None:
            self.assertTrue(restarted_game.current_dot1.x != original_dot1.x or \
                            restarted_game.current_dot1.y != original_dot1.y,
                            "Restarted game's dot1 should ideally be different from the previous game's last dot1. (Probabilistic test)")


if __name__ == '__main__':
    unittest.main()
